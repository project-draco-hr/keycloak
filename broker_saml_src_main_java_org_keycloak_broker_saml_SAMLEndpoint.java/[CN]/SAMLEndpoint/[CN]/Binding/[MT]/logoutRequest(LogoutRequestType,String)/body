{
  UserModel user=session.users().getUserByUsername(request.getNameID().getValue(),realm);
  if (user == null) {
    event.event(EventType.LOGOUT);
    event.error(Errors.USER_SESSION_NOT_FOUND);
    return Flows.forwardToSecurityFailurePage(session,realm,uriInfo,headers,Messages.IDENTITY_PROVIDER_UNEXPECTED_ERROR);
  }
  List<UserSessionModel> sessions=session.sessions().getUserSessions(realm,user);
  if (sessions == null || sessions.size() == 0) {
    event.event(EventType.LOGOUT);
    event.error(Errors.USER_SESSION_NOT_FOUND);
    return Flows.forwardToSecurityFailurePage(session,realm,uriInfo,headers,Messages.IDENTITY_PROVIDER_UNEXPECTED_ERROR);
  }
  for (  UserSessionModel userSession : sessions) {
    String brokerId=userSession.getNote(IdentityBrokerService.BROKER_PROVIDER_ID);
    if (!config.getAlias().equals(brokerId))     continue;
    boolean logout=false;
    if (request.getSessionIndex() == null || request.getSessionIndex().size() == 0) {
      logout=true;
    }
 else {
      for (      String sessionIndex : request.getSessionIndex()) {
        if (sessionIndex.equals(userSession.getNote(SAML_FEDERATED_SESSION_INDEX))) {
          logout=true;
          break;
        }
      }
    }
    if (logout) {
      try {
        AuthenticationManager.backchannelLogout(session,realm,userSession,uriInfo,clientConnection,headers);
      }
 catch (      Exception e) {
        logger.error("Failed to logout",e);
      }
    }
    String issuerURL=getEntityId(uriInfo,realm);
    SAML2LogoutResponseBuilder builder=new SAML2LogoutResponseBuilder();
    builder.logoutRequestID(request.getID());
    builder.destination(config.getSingleLogoutServiceUrl());
    builder.issuer(issuerURL);
    builder.relayState(relayState);
    if (config.isWantAuthnRequestsSigned()) {
      builder.signWith(realm.getPrivateKey(),realm.getPublicKey(),realm.getCertificate()).signDocument();
    }
    try {
      if (config.isPostBindingResponse()) {
        return builder.postBinding().response();
      }
 else {
        return builder.redirectBinding().response();
      }
    }
 catch (    ConfigurationException e) {
      throw new RuntimeException(e);
    }
catch (    ProcessingException e) {
      throw new RuntimeException(e);
    }
catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
  throw new RuntimeException("Unreachable");
}
