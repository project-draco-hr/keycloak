{
  UserRepresentation userRep=ModelToRepresentation.toRepresentation(user);
  Set<FederatedIdentityModel> socialLinks=session.users().getFederatedIdentities(user,realm);
  List<FederatedIdentityRepresentation> socialLinkReps=new ArrayList<FederatedIdentityRepresentation>();
  for (  FederatedIdentityModel socialLink : socialLinks) {
    FederatedIdentityRepresentation socialLinkRep=exportSocialLink(socialLink);
    socialLinkReps.add(socialLinkRep);
  }
  if (socialLinkReps.size() > 0) {
    userRep.setFederatedIdentities(socialLinkReps);
  }
  Set<RoleModel> roles=user.getRoleMappings();
  List<String> realmRoleNames=new ArrayList<>();
  Map<String,List<String>> clientRoleNames=new HashMap<>();
  for (  RoleModel role : roles) {
    if (role.getContainer() instanceof RealmModel) {
      realmRoleNames.add(role.getName());
    }
 else {
      ClientModel client=(ClientModel)role.getContainer();
      String clientId=client.getClientId();
      List<String> currentClientRoles=clientRoleNames.get(clientId);
      if (currentClientRoles == null) {
        currentClientRoles=new ArrayList<>();
        clientRoleNames.put(clientId,currentClientRoles);
      }
      currentClientRoles.add(role.getName());
    }
  }
  if (realmRoleNames.size() > 0) {
    userRep.setRealmRoles(realmRoleNames);
  }
  if (clientRoleNames.size() > 0) {
    userRep.setClientRoles(clientRoleNames);
  }
  List<UserCredentialValueModel> creds=user.getCredentialsDirectly();
  List<CredentialRepresentation> credReps=new ArrayList<CredentialRepresentation>();
  for (  UserCredentialValueModel cred : creds) {
    CredentialRepresentation credRep=exportCredential(cred);
    credReps.add(credRep);
  }
  userRep.setCredentials(credReps);
  userRep.setFederationLink(user.getFederationLink());
  List<UserConsentModel> consents=user.getConsents();
  LinkedList<UserConsentRepresentation> consentReps=new LinkedList<UserConsentRepresentation>();
  for (  UserConsentModel consent : consents) {
    UserConsentRepresentation consentRep=ModelToRepresentation.toRepresentation(consent);
    consentReps.add(consentRep);
  }
  if (consentReps.size() > 0) {
    userRep.setClientConsents(consentReps);
  }
  if (user.getServiceAccountClientLink() != null) {
    String clientInternalId=user.getServiceAccountClientLink();
    ClientModel client=realm.getClientById(clientInternalId);
    if (client != null) {
      userRep.setServiceAccountClientId(client.getClientId());
    }
  }
  List<OfflineUserSessionRepresentation> offlineSessionReps=new LinkedList<>();
  Collection<OfflineUserSessionModel> offlineSessions=session.users().getOfflineUserSessions(realm,user);
  Collection<OfflineClientSessionModel> offlineClientSessions=session.users().getOfflineClientSessions(realm,user);
  Map<String,List<OfflineClientSessionModel>> processed=new HashMap<>();
  for (  OfflineClientSessionModel clsm : offlineClientSessions) {
    String userSessionId=clsm.getUserSessionId();
    List<OfflineClientSessionModel> current=processed.get(userSessionId);
    if (current == null) {
      current=new LinkedList<>();
      processed.put(userSessionId,current);
    }
    current.add(clsm);
  }
  for (  OfflineUserSessionModel userSession : offlineSessions) {
    OfflineUserSessionRepresentation sessionRep=ModelToRepresentation.toRepresentation(realm,userSession,processed.get(userSession.getUserSessionId()));
    offlineSessionReps.add(sessionRep);
  }
  userRep.setOfflineUserSessions(offlineSessionReps);
  return userRep;
}
