{
  if (realmInfo.isSslRequired() && !isRequestSecure()) {
    log.error("SSL is required");
    sendError(Response.Status.FORBIDDEN.getStatusCode());
    return false;
  }
  if (!checkStateCookie())   return false;
  String client_id=realmInfo.getClientId();
  String password=realmInfo.getCredentials().asMap().getFirst("password");
  String redirectUri=stripOauthParametersFromRedirect();
  Form form=new Form();
  form.param("grant_type","authorization_code").param("code",code).param("client_id",client_id).param(RequiredCredentialRepresentation.PASSWORD,password).param("redirect_uri",redirectUri);
  Response res=realmInfo.getCodeUrl().request().post(Entity.form(form));
  AccessTokenResponse tokenResponse;
  try {
    if (res.getStatus() != 200) {
      log.error("failed to turn code into token");
      log.error("status from server: " + res.getStatus());
      if (res.getStatus() == 400 && res.getMediaType() != null) {
        log.error("   " + res.readEntity(String.class));
      }
      sendError(Response.Status.FORBIDDEN.getStatusCode());
      return false;
    }
    log.debug("media type: " + res.getMediaType());
    log.debug("Content-Type header: " + res.getHeaderString("Content-Type"));
    tokenResponse=res.readEntity(AccessTokenResponse.class);
  }
  finally {
    res.close();
  }
  tokenString=tokenResponse.getToken();
  try {
    token=RSATokenVerifier.verifyToken(tokenString,realmInfo.getMetadata());
    log.info("Token Verification succeeded!");
  }
 catch (  VerificationException e) {
    log.error("failed verification of token");
    sendError(Response.Status.FORBIDDEN.getStatusCode());
    return false;
  }
  sendRedirect(redirectUri);
  return true;
}
