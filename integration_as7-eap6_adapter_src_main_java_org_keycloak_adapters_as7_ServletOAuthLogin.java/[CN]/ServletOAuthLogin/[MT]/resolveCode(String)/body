{
  if (realmInfo.isSslRequired() && !isRequestSecure()) {
    log.error("SSL is required");
    sendError(HttpServletResponse.SC_FORBIDDEN);
    return false;
  }
  if (!checkStateCookie())   return false;
  String redirectUri=stripOauthParametersFromRedirect();
  AccessTokenResponse tokenResponse=null;
  try {
    tokenResponse=TokenGrantRequest.invokeAccessCodeToToken(realmInfo,code,redirectUri);
  }
 catch (  TokenGrantRequest.HttpFailure failure) {
    log.error("failed to turn code into token");
    log.error("status from server: " + failure.getStatus());
    if (failure.getStatus() == HttpServletResponse.SC_BAD_REQUEST && failure.getError() != null) {
      log.error("   " + failure.getError());
    }
    sendError(HttpServletResponse.SC_FORBIDDEN);
    return false;
  }
catch (  IOException e) {
    log.error("failed to turn code into token");
    sendError(HttpServletResponse.SC_FORBIDDEN);
  }
  tokenString=tokenResponse.getToken();
  idTokenString=tokenResponse.getIdToken();
  try {
    token=RSATokenVerifier.verifyToken(tokenString,realmInfo.getMetadata().getRealmKey(),realmInfo.getMetadata().getRealm());
    if (idTokenString != null) {
      JWSInput input=new JWSInput(idTokenString);
      try {
        idToken=input.readJsonContent(IDToken.class);
      }
 catch (      IOException e) {
        throw new VerificationException();
      }
    }
    log.debug("Token Verification succeeded!");
  }
 catch (  VerificationException e) {
    log.error("failed verification of token");
    sendError(HttpServletResponse.SC_FORBIDDEN);
    return false;
  }
  refreshToken=tokenResponse.getRefreshToken();
  sendRedirect(redirectUri);
  return true;
}
