{
  String authHeader=request.getHeaderString(HttpHeaders.AUTHORIZATION);
  if (authHeader == null) {
    challengeResponse(request,null,null);
    return;
  }
  String[] split=authHeader.trim().split("\\s+");
  if (split == null || split.length != 2)   challengeResponse(request,null,null);
  if (!split[0].equalsIgnoreCase("Bearer"))   challengeResponse(request,null,null);
  String tokenString=split[1];
  try {
    AccessToken token=RSATokenVerifier.verifyToken(tokenString,resourceMetadata.getRealmKey(),resourceMetadata.getRealm());
    KeycloakAuthenticatedSession skSession=new KeycloakAuthenticatedSession(tokenString,token,resourceMetadata);
    ResteasyProviderFactory.pushContext(KeycloakAuthenticatedSession.class,skSession);
    String callerPrincipal=securityContext.getUserPrincipal() != null ? securityContext.getUserPrincipal().getName() : null;
    final KeycloakPrincipal principal=new KeycloakPrincipal(token.getSubject(),callerPrincipal);
    final boolean isSecure=securityContext.isSecure();
    final AccessToken.Access access;
    if (resourceMetadata.getResourceName() != null) {
      access=token.getResourceAccess(resourceMetadata.getResourceName());
    }
 else {
      access=token.getRealmAccess();
    }
    SecurityContext ctx=new SecurityContext(){
      @Override public Principal getUserPrincipal(){
        return principal;
      }
      @Override public boolean isUserInRole(      String role){
        if (access.getRoles() == null)         return false;
        return access.getRoles().contains(role);
      }
      @Override public boolean isSecure(){
        return isSecure;
      }
      @Override public String getAuthenticationScheme(){
        return "OAUTH_BEARER";
      }
    }
;
    request.setSecurityContext(ctx);
  }
 catch (  VerificationException e) {
    log.error("Failed to verify token",e);
    challengeResponse(request,"invalid_token",e.getMessage());
  }
}
