{
  if (realmInfo.isSslRequired() && !isRequestSecure()) {
    log.error("SSL is required");
    return challenge(StatusCodes.FORBIDDEN);
  }
  log.info("checking state cookie for after code");
  KeycloakChallenge challenge=checkStateCookie();
  if (challenge != null)   return challenge;
  AccessTokenResponse tokenResponse=null;
  String redirectUri=stripOauthParametersFromRedirect();
  try {
    tokenResponse=TokenGrantRequest.invokeAccessCodeToToken(realmInfo,code,redirectUri);
  }
 catch (  TokenGrantRequest.HttpFailure failure) {
    log.error("failed to turn code into token");
    log.error("status from server: " + failure.getStatus());
    if (failure.getStatus() == StatusCodes.BAD_REQUEST && failure.getError() != null) {
      log.error("   " + failure.getError());
    }
    return challenge(StatusCodes.FORBIDDEN);
  }
catch (  IOException e) {
    log.error("failed to turn code into token",e);
    return challenge(StatusCodes.FORBIDDEN);
  }
  tokenString=tokenResponse.getToken();
  refreshToken=tokenResponse.getRefreshToken();
  idTokenString=tokenResponse.getIdToken();
  try {
    token=RSATokenVerifier.verifyToken(tokenString,realmInfo.getMetadata().getRealmKey(),realmInfo.getMetadata().getRealm());
    if (idTokenString != null) {
      JWSInput input=new JWSInput(idTokenString);
      try {
        idToken=input.readJsonContent(IDToken.class);
      }
 catch (      IOException e) {
        throw new VerificationException();
      }
    }
    log.debug("Token Verification succeeded!");
  }
 catch (  VerificationException e) {
    log.error("failed verification of token");
    return challenge(StatusCodes.FORBIDDEN);
  }
  log.info("successful authenticated");
  return null;
}
