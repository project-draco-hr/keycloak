{
  logger.tracev("getConsents: {0}",user.getUsername());
  String cacheKey=getConsentCacheKey(user.getId());
  if (realmInvalidations.contains(realm.getId()) || invalidations.contains(user.getId()) || invalidations.contains(cacheKey)) {
    return getDelegate().getConsents(realm,user);
  }
  CachedUserConsents cached=cache.get(cacheKey,CachedUserConsents.class);
  if (cached == null) {
    Long loaded=cache.getCurrentRevision(cacheKey);
    List<UserConsentModel> consents=getDelegate().getConsents(realm,user);
    cached=new CachedUserConsents(loaded,cacheKey,realm,consents);
    cache.addRevisioned(cached,startupRevision);
    return consents;
  }
 else {
    List<UserConsentModel> result=new LinkedList<>();
    for (    CachedUserConsent cachedConsent : cached.getConsents().values()) {
      UserConsentModel consent=toConsentModel(realm,cachedConsent);
      if (consent != null) {
        result.add(consent);
      }
    }
    return result;
  }
}
