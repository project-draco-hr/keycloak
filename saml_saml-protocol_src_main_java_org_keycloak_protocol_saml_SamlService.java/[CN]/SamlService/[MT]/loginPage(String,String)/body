{
  event.event(EventType.LOGIN);
  if (!checkSsl()) {
    event.error(Errors.SSL_REQUIRED);
    return Flows.forwardToSecurityFailurePage(session,realm,uriInfo,"HTTPS required");
  }
  if (!realm.isEnabled()) {
    event.error(Errors.REALM_DISABLED);
    return Flows.forwardToSecurityFailurePage(session,realm,uriInfo,"Realm not enabled");
  }
  if (samlRequest == null) {
    event.error(Errors.INVALID_TOKEN);
    return Flows.forwardToSecurityFailurePage(session,realm,uriInfo,"Invalid Request");
  }
  SAMLDocumentHolder documentHolder=SAMLRequestParser.parsePostBinding(samlRequest);
  if (documentHolder == null) {
    event.error(Errors.INVALID_TOKEN);
    return Flows.forwardToSecurityFailurePage(session,realm,uriInfo,"Invalid Request");
  }
  SAML2Object samlObject=documentHolder.getSamlObject();
  if (!(samlObject instanceof AuthnRequestType)) {
    event.error(Errors.INVALID_TOKEN);
    return Flows.forwardToSecurityFailurePage(session,realm,uriInfo,"Invalid Request");
  }
  AuthnRequestType requestAbstractType=(AuthnRequestType)samlObject;
  String issuer=requestAbstractType.getIssuer().getValue();
  ClientModel client=realm.findClient(issuer);
  if (client == null) {
    event.error(Errors.CLIENT_NOT_FOUND);
    return Flows.forwardToSecurityFailurePage(session,realm,uriInfo,"Unknown login requester.");
  }
  if (!client.isEnabled()) {
    event.error(Errors.CLIENT_DISABLED);
    return Flows.forwardToSecurityFailurePage(session,realm,uriInfo,"Login requester not enabled.");
  }
  if ((client instanceof ApplicationModel) && ((ApplicationModel)client).isBearerOnly()) {
    event.error(Errors.NOT_ALLOWED);
    return Flows.forwardToSecurityFailurePage(session,realm,uriInfo,"Bearer-only applications are not allowed to initiate browser login");
  }
  if (client.isDirectGrantsOnly()) {
    event.error(Errors.NOT_ALLOWED);
    return Flows.forwardToSecurityFailurePage(session,realm,uriInfo,"direct-grants-only clients are not allowed to initiate browser login");
  }
  URI redirectUri=requestAbstractType.getAssertionConsumerServiceURL();
  String redirect=OpenIDConnectService.verifyRedirectUri(uriInfo,redirectUri.toString(),realm,client);
  if (redirect == null) {
    event.error(Errors.INVALID_REDIRECT_URI);
    return Flows.forwardToSecurityFailurePage(session,realm,uriInfo,"Invalid redirect_uri.");
  }
  ClientSessionModel clientSession=session.sessions().createClientSession(realm,client);
  clientSession.setAuthMethod(SamlLogin.LOGIN_PROTOCOL);
  clientSession.setRedirectUri(redirect);
  clientSession.setAction(ClientSessionModel.Action.AUTHENTICATE);
  clientSession.setNote(SamlLogin.SAML_BINDING,SamlLogin.SAML_POST_BINDING);
  clientSession.setNote(GeneralConstants.RELAY_STATE,relayState);
  clientSession.setNote("REQUEST_ID",requestAbstractType.getID());
  Response response=authManager.checkNonFormAuthentication(session,clientSession,realm,uriInfo,request,clientConnection,headers,event);
  if (response != null)   return response;
  LoginFormsProvider forms=Flows.forms(session,realm,clientSession.getClient(),uriInfo).setClientSessionCode(new ClientSessionCode(realm,clientSession).getCode());
  String rememberMeUsername=null;
  if (realm.isRememberMe()) {
    Cookie rememberMeCookie=headers.getCookies().get(AuthenticationManager.KEYCLOAK_REMEMBER_ME);
    if (rememberMeCookie != null && !"".equals(rememberMeCookie.getValue())) {
      rememberMeUsername=rememberMeCookie.getValue();
    }
  }
  if (rememberMeUsername != null) {
    MultivaluedMap<String,String> formData=new MultivaluedMapImpl<String,String>();
    formData.add(AuthenticationManager.FORM_USERNAME,rememberMeUsername);
    formData.add("rememberMe","on");
    forms.setFormData(formData);
  }
  return forms.createLogin();
}
