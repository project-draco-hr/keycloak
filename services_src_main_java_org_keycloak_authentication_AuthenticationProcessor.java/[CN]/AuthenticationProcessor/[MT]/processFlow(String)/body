{
  AuthenticationFlowModel flow=realm.getAuthenticationFlowById(flowId);
  if (flow == null) {
    logger.error("Unknown flow to execute with");
    throw new AuthException(Error.INTERNAL_ERROR);
  }
  List<AuthenticationExecutionModel> executions=realm.getAuthenticationExecutions(flowId);
  if (executions == null)   return null;
  Response alternativeChallenge=null;
  boolean alternativeSuccessful=false;
  for (  AuthenticationExecutionModel model : executions) {
    if (isProcessed(model)) {
      if (!alternativeSuccessful && model.isAlternative() && isSuccessful(model))       alternativeSuccessful=true;
      continue;
    }
    Result context=null;
    if (model.isAlternative() && alternativeSuccessful) {
      clientSession.setAuthenticatorStatus(model.getId(),UserSessionModel.AuthenticatorStatus.SKIPPED);
      continue;
    }
    if (model.isAutheticatorFlow()) {
      Response flowResponse=processFlow(model.getAuthenticator());
      if (flowResponse == null) {
        clientSession.setAuthenticatorStatus(model.getId(),UserSessionModel.AuthenticatorStatus.SUCCESS);
        if (model.isAlternative())         alternativeSuccessful=true;
        continue;
      }
 else {
        return flowResponse;
      }
    }
    AuthenticatorModel authenticatorModel=realm.getAuthenticatorById(model.getAuthenticator());
    AuthenticatorFactory factory=(AuthenticatorFactory)session.getKeycloakSessionFactory().getProviderFactory(Authenticator.class,authenticatorModel.getProviderId());
    Authenticator authenticator=factory.create(authenticatorModel);
    UserModel authUser=clientSession.getAuthenticatedUser();
    if (authenticator.requiresUser() && authUser == null) {
      if (alternativeChallenge != null)       return alternativeChallenge;
      throw new AuthException(Error.UNKNOWN_USER);
    }
    if (authenticator.requiresUser() && authUser != null && !authenticator.configuredFor(authUser)) {
      if (model.getRequirement() == AuthenticationExecutionModel.Requirement.REQUIRED) {
        if (model.isUserSetupAllowed()) {
          clientSession.setAuthenticatorStatus(model.getId(),UserSessionModel.AuthenticatorStatus.SETUP_REQUIRED);
          authUser.addRequiredAction(authenticator.getRequiredAction());
        }
 else {
          throw new AuthException(Error.CREDENTIAL_SETUP_REQUIRED);
        }
      }
      continue;
    }
    context=new Result(authenticatorModel,authenticator);
    authenticator.authenticate(context);
    Status result=context.getStatus();
    if (result == Status.SUCCESS) {
      clientSession.setAuthenticatorStatus(model.getId(),UserSessionModel.AuthenticatorStatus.SUCCESS);
      if (model.isAlternative())       alternativeSuccessful=true;
      continue;
    }
 else     if (result == Status.FAILED) {
      logUserFailure();
      if (context.challenge != null)       return context.challenge;
      throw new AuthException(context.error);
    }
 else     if (result == Status.CHALLENGE) {
      if (model.isRequired())       return context.challenge;
 else       if (model.isAlternative())       alternativeChallenge=context.challenge;
 else       clientSession.setAuthenticatorStatus(model.getId(),UserSessionModel.AuthenticatorStatus.SKIPPED);
      continue;
    }
 else     if (result == Status.FAILURE_CHALLENGE) {
      logUserFailure();
      return context.challenge;
    }
 else     if (result == Status.ATTEMPTED) {
      if (model.getRequirement() == AuthenticationExecutionModel.Requirement.REQUIRED)       throw new AuthException(Error.INVALID_CREDENTIALS);
      clientSession.setAuthenticatorStatus(model.getId(),UserSessionModel.AuthenticatorStatus.ATTEMPTED);
      continue;
    }
  }
  return null;
}
