{
  try {
    EventBuilder event=new EventsManager(this.realmModel,this.session,this.clientConnection).createEventBuilder().event(EventType.USER_INFO_REQUEST).detail(Details.AUTH_METHOD,Details.VALIDATE_ACCESS_TOKEN);
    Response validationResponse=this.openIdConnectService.validateAccessToken(token);
    if (!AccessToken.class.isInstance(validationResponse.getEntity())) {
      event.error(EventType.USER_INFO_REQUEST.name());
      return Response.fromResponse(validationResponse).status(Status.FORBIDDEN).build();
    }
    AccessToken accessToken=(AccessToken)validationResponse.getEntity();
    UserSessionModel userSession=session.sessions().getUserSession(realmModel,accessToken.getSessionState());
    ClientModel clientModel=realmModel.findClient(accessToken.getIssuedFor());
    UserModel userModel=userSession.getUser();
    AccessToken userInfo=new AccessToken();
    this.tokenManager.transformToken(session,userInfo,realmModel,clientModel,userModel,userSession,null);
    event.detail(Details.USERNAME,userModel.getUsername()).client(clientModel).session(userSession).user(userModel).success();
    Map<String,Object> claims=new HashMap<String,Object>();
    claims.putAll(userInfo.getOtherClaims());
    claims.put("sub",userModel.getId());
    return Cors.add(request,Response.ok(claims)).auth().allowedOrigins(accessToken).build();
  }
 catch (  Exception e) {
    throw new UnauthorizedException("Could not retrieve user info.",e);
  }
}
