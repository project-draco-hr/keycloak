{
  EventBuilder event=new EventBuilder(realm,session,clientConnection).event(EventType.USER_INFO_REQUEST).detail(Details.AUTH_METHOD,Details.VALIDATE_ACCESS_TOKEN);
  AccessToken token=null;
  try {
    token=RSATokenVerifier.verifyToken(tokenString,realm.getPublicKey(),Urls.realmIssuer(uriInfo.getBaseUri(),realm.getName()),true);
  }
 catch (  VerificationException e) {
    throw new ErrorResponseException(OAuthErrorException.INVALID_GRANT,"Token invalid: " + e.getMessage(),Status.FORBIDDEN);
  }
  UserSessionModel userSession=session.sessions().getUserSession(realm,token.getSessionState());
  ClientSessionModel clientSession=session.sessions().getClientSession(token.getClientSession());
  if (userSession == null || clientSession == null || !AuthenticationManager.isSessionValid(realm,userSession)) {
    throw new ErrorResponseException(OAuthErrorException.INVALID_GRANT,"Token invalid",Status.FORBIDDEN);
  }
  ClientModel clientModel=realm.getClientByClientId(token.getIssuedFor());
  UserModel userModel=userSession.getUser();
  AccessToken userInfo=new AccessToken();
  tokenManager.transformAccessToken(session,userInfo,realm,clientModel,userModel,userSession,clientSession);
  event.detail(Details.USERNAME,userModel.getUsername()).client(clientModel).session(userSession).user(userModel).success();
  Map<String,Object> claims=new HashMap<String,Object>();
  claims.putAll(userInfo.getOtherClaims());
  claims.put("sub",userModel.getId());
  return Cors.add(request,Response.ok(claims)).auth().allowedOrigins(token).build();
}
