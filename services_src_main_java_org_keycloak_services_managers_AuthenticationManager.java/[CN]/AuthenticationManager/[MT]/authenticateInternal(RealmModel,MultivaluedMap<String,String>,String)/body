{
  UserModel user=KeycloakModelUtils.findUserByNameOrEmail(realm,username);
  Set<String> types=new HashSet<String>();
  for (  RequiredCredentialModel credential : realm.getRequiredCredentials()) {
    types.add(credential.getType());
  }
  if (types.contains(CredentialRepresentation.PASSWORD)) {
    String password=formData.getFirst(CredentialRepresentation.PASSWORD);
    if (password == null) {
      logger.warn("Password not provided");
      return AuthenticationStatus.MISSING_PASSWORD;
    }
    if (user == null && types.contains(CredentialRepresentation.TOTP)) {
      logger.warn("User doesn't exists and TOTP is required for the realm");
      return AuthenticationStatus.INVALID_USER;
    }
    if (user != null && user.isTotp()) {
      String token=formData.getFirst(CredentialRepresentation.TOTP);
      if (token == null) {
        logger.warn("TOTP token not provided");
        return AuthenticationStatus.MISSING_TOTP;
      }
      if (!checkEnabled(user)) {
        return AuthenticationStatus.ACCOUNT_DISABLED;
      }
      logger.debug("validating TOTP");
      if (!realm.validateTOTP(user,password,token)) {
        return AuthenticationStatus.INVALID_CREDENTIALS;
      }
    }
 else {
      logger.debug("validating password for user: " + username);
      AuthResult authResult=AuthenticationProviderManager.getManager(realm).validatePassword(username,password);
      if (authResult.getAuthProviderStatus() == AuthProviderStatus.INVALID_CREDENTIALS) {
        logger.debug("invalid password for user: " + username);
        return AuthenticationStatus.INVALID_CREDENTIALS;
      }
 else       if (authResult.getAuthProviderStatus() == AuthProviderStatus.USER_NOT_FOUND) {
        logger.debug("User " + username + " not found in any Authentication provider");
        return AuthenticationStatus.INVALID_USER;
      }
      if (authResult.getAuthenticatedUser() != null) {
        AuthenticatedUser authUser=authResult.getAuthenticatedUser();
        AuthenticationLinkModel authLink=new AuthenticationLinkModel(authResult.getProviderName(),authUser.getId());
        user=realm.getUserByAuthenticationLink(authLink);
        if (user == null) {
          user=KeycloakModelUtils.findUserByNameOrEmail(realm,username);
          if (user != null) {
            realm.addAuthenticationLink(user,authLink);
            logger.info("User " + authUser.getUsername() + " successfully authenticated and linked with provider "+ authResult.getProviderName());
          }
 else {
            user=realm.addUser(authUser.getUsername());
            user.setEnabled(true);
            user.setFirstName(authUser.getFirstName());
            user.setLastName(authUser.getLastName());
            user.setEmail(authUser.getEmail());
            realm.addAuthenticationLink(user,authLink);
            logger.info("User " + username + " successfully authenticated and created based on provider "+ authResult.getProviderName());
          }
        }
 else {
        }
        if (!username.equals(user.getLoginName())) {
          formData.putSingle(FORM_USERNAME,user.getLoginName());
          logger.debug("Existing user " + user.getLoginName() + " successfully authenticated");
        }
      }
 else {
        if (user == null) {
          logger.warn("User '" + username + "' successfully authenticated, but he doesn't exists and don't know how to create him");
          return AuthenticationStatus.INVALID_USER;
        }
      }
      if (!checkEnabled(user)) {
        return AuthenticationStatus.ACCOUNT_DISABLED;
      }
    }
    if (!user.getRequiredActions().isEmpty()) {
      return AuthenticationStatus.ACTIONS_REQUIRED;
    }
 else {
      return AuthenticationStatus.SUCCESS;
    }
  }
 else   if (types.contains(CredentialRepresentation.SECRET)) {
    String secret=formData.getFirst(CredentialRepresentation.SECRET);
    if (secret == null) {
      logger.warn("Secret not provided");
      return AuthenticationStatus.MISSING_PASSWORD;
    }
    if (!user.getRequiredActions().isEmpty()) {
      return AuthenticationStatus.ACTIONS_REQUIRED;
    }
 else {
      return AuthenticationStatus.SUCCESS;
    }
  }
 else {
    logger.warn("Do not know how to authenticate user");
    return AuthenticationStatus.FAILED;
  }
}
