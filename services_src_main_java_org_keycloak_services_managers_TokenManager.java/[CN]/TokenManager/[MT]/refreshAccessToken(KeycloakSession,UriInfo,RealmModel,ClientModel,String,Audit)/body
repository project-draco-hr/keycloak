{
  JWSInput jws=new JWSInput(encodedRefreshToken);
  RefreshToken refreshToken=null;
  try {
    if (!RSAProvider.verify(jws,realm.getPublicKey())) {
      throw new RuntimeException("Invalid refresh token");
    }
    refreshToken=jws.readJsonContent(RefreshToken.class);
  }
 catch (  IOException e) {
    throw new OAuthErrorException(OAuthErrorException.INVALID_GRANT,"Invalid refresh token",e);
  }
  if (refreshToken.isExpired()) {
    throw new OAuthErrorException(OAuthErrorException.INVALID_GRANT,"Refresh token expired");
  }
  if (refreshToken.getIssuedAt() < realm.getNotBefore()) {
    throw new OAuthErrorException(OAuthErrorException.INVALID_GRANT,"Stale refresh token");
  }
  audit.user(refreshToken.getSubject()).session(refreshToken.getSessionState()).detail(Details.REFRESH_TOKEN_ID,refreshToken.getId());
  UserModel user=realm.getUserById(refreshToken.getSubject());
  if (user == null) {
    throw new OAuthErrorException(OAuthErrorException.INVALID_GRANT,"Invalid refresh token","Unknown user");
  }
  if (!user.isEnabled()) {
    throw new OAuthErrorException(OAuthErrorException.INVALID_GRANT,"User disabled","User disabled");
  }
  UserSessionModel userSession=session.sessions().getUserSession(realm,refreshToken.getSessionState());
  int currentTime=Time.currentTime();
  if (!AuthenticationManager.isSessionValid(realm,userSession)) {
    AuthenticationManager.logout(session,realm,userSession,uriInfo);
    throw new OAuthErrorException(OAuthErrorException.INVALID_GRANT,"Session not active","Session not active");
  }
  if (!client.getClientId().equals(refreshToken.getIssuedFor())) {
    throw new OAuthErrorException(OAuthErrorException.INVALID_GRANT,"Unmatching clients","Unmatching clients");
  }
  if (refreshToken.getIssuedAt() < client.getNotBefore()) {
    throw new OAuthErrorException(OAuthErrorException.INVALID_GRANT,"Stale refresh token");
  }
  ApplicationModel clientApp=(client instanceof ApplicationModel) ? (ApplicationModel)client : null;
  if (refreshToken.getRealmAccess() != null) {
    for (    String roleName : refreshToken.getRealmAccess().getRoles()) {
      RoleModel role=realm.getRole(roleName);
      if (role == null) {
        throw new OAuthErrorException(OAuthErrorException.INVALID_GRANT,"Invalid realm role " + roleName);
      }
      if (!user.hasRole(role)) {
        throw new OAuthErrorException(OAuthErrorException.INVALID_SCOPE,"User no long has permission for realm role: " + roleName);
      }
      if (!client.hasScope(role)) {
        throw new OAuthErrorException(OAuthErrorException.INVALID_SCOPE,"Client no longer has realm scope: " + roleName);
      }
    }
  }
  if (refreshToken.getResourceAccess() != null) {
    for (    Map.Entry<String,AccessToken.Access> entry : refreshToken.getResourceAccess().entrySet()) {
      ApplicationModel app=realm.getApplicationByName(entry.getKey());
      if (app == null) {
        throw new OAuthErrorException(OAuthErrorException.INVALID_SCOPE,"Application no longer exists","Application no longer exists: " + app.getName());
      }
      for (      String roleName : entry.getValue().getRoles()) {
        RoleModel role=app.getRole(roleName);
        if (role == null) {
          throw new OAuthErrorException(OAuthErrorException.INVALID_GRANT,"Invalid refresh token","Unknown application role: " + roleName);
        }
        if (!user.hasRole(role)) {
          throw new OAuthErrorException(OAuthErrorException.INVALID_SCOPE,"User no long has permission for application role " + roleName);
        }
        if (clientApp != null && !clientApp.equals(app) && !client.hasScope(role)) {
          throw new OAuthErrorException(OAuthErrorException.INVALID_SCOPE,"Client no longer has application scope" + roleName);
        }
      }
    }
  }
  AccessToken accessToken=initToken(realm,client,user,userSession);
  accessToken.setRealmAccess(refreshToken.getRealmAccess());
  accessToken.setResourceAccess(refreshToken.getResourceAccess());
  if (currentTime + realm.getAccessTokenLifespan() > userSession.getLastSessionRefresh() + realm.getSsoSessionIdleTimeout()) {
    userSession.setLastSessionRefresh(currentTime);
  }
  return accessToken;
}
