{
  ClientSessionModel clientSession=clientCode.getClientSession();
  FederatedIdentityModel federatedIdentityModel=new FederatedIdentityModel(providerId,updatedIdentity.getId(),updatedIdentity.getUsername(),updatedIdentity.getToken());
  UserModel federatedUser=session.users().getUserByFederatedIdentity(federatedIdentityModel,realm);
  IdentityProviderModel identityProviderConfig=getIdentityProviderConfig(realm,providerId);
  String authMethod=federatedIdentityModel.getUserId() + "@" + identityProviderConfig.getId();
  EventBuilder event=new EventsManager(realm,session,clientConnection).createEventBuilder().event(EventType.LOGIN).client(clientSession.getClient()).detail(Details.REDIRECT_URI,clientSession.getRedirectUri()).detail(Details.AUTH_METHOD,authMethod);
  event.detail(Details.USERNAME,authMethod);
  if (clientSession.getUserSession() != null) {
    UserModel authenticatedUser=clientSession.getUserSession().getUser();
    if (federatedUser != null) {
      String message="The updatedIdentity returned by the Identity Provider [" + identityProviderConfig.getName() + "] is already linked to other user";
      event.error(message);
      return redirectToErrorPage(realm,message);
    }
    if (!authenticatedUser.isEnabled()) {
      event.error(Errors.USER_DISABLED);
      return redirectToErrorPage(realm,"User is disabled");
    }
    if (!authenticatedUser.hasRole(realm.getApplicationByName(ACCOUNT_MANAGEMENT_APP).getRole(MANAGE_ACCOUNT))) {
      event.error(Errors.NOT_ALLOWED);
      return redirectToErrorPage(realm,"Insufficient permissions to link updatedIdentity");
    }
    session.users().addFederatedIdentity(realm,authenticatedUser,federatedIdentityModel);
    event.success();
    return Response.status(302).location(UriBuilder.fromUri(clientSession.getRedirectUri()).build()).build();
  }
  if (federatedUser == null) {
    String errorMessage=null;
    UserModel existingUser=session.users().getUserByEmail(updatedIdentity.getEmail(),realm);
    if (existingUser != null) {
      event.error(Errors.FEDERATED_IDENTITY_EMAIL_EXISTS);
      errorMessage="federatedIdentityEmailExists";
    }
 else {
      existingUser=session.users().getUserByUsername(updatedIdentity.getUsername(),realm);
      if (existingUser != null) {
        event.error(Errors.FEDERATED_IDENTITY_USERNAME_EXISTS);
        errorMessage="federatedIdentityUsernameExists";
      }
    }
    if (!realm.isRegistrationAllowed()) {
      event.error(Errors.FEDERATED_IDENTITY_DISABLED_REGISTRATION);
      errorMessage="federatedIdentityDisabledRegistration";
    }
    if (errorMessage == null) {
      logger.debug("Creating user " + updatedIdentity.getUsername() + " and linking to federation provider "+ providerId);
      federatedUser=session.users().addUser(realm,updatedIdentity.getUsername());
      federatedUser.setEnabled(true);
      federatedUser.setFirstName(updatedIdentity.getFirstName());
      federatedUser.setLastName(updatedIdentity.getLastName());
      federatedUser.setEmail(updatedIdentity.getEmail());
      session.users().addFederatedIdentity(realm,federatedUser,federatedIdentityModel);
      event.clone().user(federatedUser).event(EventType.REGISTER).detail(Details.REGISTER_METHOD,authMethod).detail(Details.EMAIL,federatedUser.getEmail()).removeDetail("auth_method").success();
      if (identityProviderConfig.isUpdateProfileFirstLogin()) {
        federatedUser.addRequiredAction(UPDATE_PROFILE);
      }
    }
 else {
      return Flows.forms(session,realm,clientSession.getClient(),uriInfo).setClientSessionCode(clientCode.getCode()).setError(errorMessage).createLogin();
    }
  }
  federatedIdentityModel=this.session.users().getFederatedIdentity(federatedUser,providerId,realm);
  federatedIdentityModel.setToken(updatedIdentity.getToken());
  this.session.users().updateFederatedIdentity(realm,federatedUser,federatedIdentityModel);
  event.user(federatedUser);
  String username=federatedIdentityModel.getUserId() + "@" + identityProviderConfig.getName();
  UserSessionModel userSession=session.sessions().createUserSession(realm,federatedUser,username,clientConnection.getRemoteAddr(),"broker",false);
  event.session(userSession);
  TokenManager.attachClientSession(userSession,clientSession);
  AuthenticationManager authManager=new AuthenticationManager();
  return authManager.nextActionAfterAuthentication(session,userSession,clientSession,clientConnection,request,uriInfo,event);
}
