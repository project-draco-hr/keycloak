{
  ClientSessionCode clientCode=null;
  IdentityProviderModel identityProviderConfig=context.getIdpConfig();
  try {
    clientCode=parseClientSessionCode(context.getCode());
  }
 catch (  Exception e) {
    return redirectToErrorPage(Messages.IDENTITY_PROVIDER_AUTHENTICATION_FAILED,e,identityProviderConfig.getProviderId());
  }
  String providerId=identityProviderConfig.getAlias();
  if (!identityProviderConfig.isStoreToken()) {
    if (isDebugEnabled()) {
      LOGGER.debugf("Token will not be stored for identity provider [%s].",providerId);
    }
    context.setToken(null);
  }
  ClientSessionModel clientSession=clientCode.getClientSession();
  context.setClientSession(clientSession);
  session.getContext().setClient(clientSession.getClient());
  context.getIdp().preprocessFederatedIdentity(session,realmModel,context);
  Set<IdentityProviderMapperModel> mappers=realmModel.getIdentityProviderMappersByAlias(context.getIdpConfig().getAlias());
  if (mappers != null) {
    KeycloakSessionFactory sessionFactory=session.getKeycloakSessionFactory();
    for (    IdentityProviderMapperModel mapper : mappers) {
      IdentityProviderMapper target=(IdentityProviderMapper)sessionFactory.getProviderFactory(IdentityProviderMapper.class,mapper.getIdentityProviderMapper());
      target.preprocessFederatedIdentity(session,realmModel,mapper,context);
    }
  }
  FederatedIdentityModel federatedIdentityModel=new FederatedIdentityModel(providerId,context.getId(),context.getUsername(),context.getToken());
  this.event.event(EventType.IDENTITY_PROVIDER_LOGIN).detail(Details.REDIRECT_URI,clientSession.getRedirectUri()).detail(Details.IDENTITY_PROVIDER_USERNAME,context.getUsername());
  UserModel federatedUser=this.session.users().getUserByFederatedIdentity(federatedIdentityModel,this.realmModel);
  if (clientSession.getUserSession() != null) {
    return performAccountLinking(clientSession,context,federatedIdentityModel,federatedUser);
  }
  if (federatedUser == null) {
    LOGGER.debugf("Federated user not found for provider '%s' and broker username '%s' . Redirecting to flow for firstBrokerLogin",providerId,context.getUsername());
    String username=context.getModelUsername();
    if (username == null) {
      if (this.realmModel.isRegistrationEmailAsUsername() && !Validation.isBlank(context.getEmail())) {
        username=context.getEmail();
      }
 else       if (context.getUsername() == null) {
        username=context.getIdpConfig().getAlias() + "." + context.getId();
      }
 else {
        username=context.getIdpConfig().getAlias() + "." + context.getUsername();
      }
    }
    username=username.trim();
    context.setModelUsername(username);
    clientSession.setTimestamp(Time.currentTime());
    SerializedBrokeredIdentityContext ctx=SerializedBrokeredIdentityContext.serialize(context);
    ctx.saveToClientSession(clientSession);
    URI redirect=LoginActionsService.firstBrokerLoginProcessor(uriInfo).queryParam(OAuth2Constants.CODE,context.getCode()).build(realmModel.getName());
    return Response.status(302).location(redirect).build();
  }
 else {
    updateFederatedIdentity(context,federatedUser);
    boolean firstBrokerLoginInProgress=(clientSession.getNote(AbstractIdpAuthenticator.BROKERED_CONTEXT_NOTE) != null);
    if (firstBrokerLoginInProgress) {
      LOGGER.debugf("Reauthenticated with broker '%s' when linking user '%s' with other broker",context.getIdpConfig().getAlias(),federatedUser.getUsername());
      UserModel linkingUser=AbstractIdpAuthenticator.getExistingUser(session,realmModel,clientSession);
      if (!linkingUser.getId().equals(federatedUser.getId())) {
        return redirectToErrorPage(Messages.IDENTITY_PROVIDER_DIFFERENT_USER_MESSAGE,federatedUser.getUsername(),linkingUser.getUsername());
      }
      clientSession.setAuthenticatedUser(federatedUser);
      return afterFirstBrokerLogin(context.getCode());
    }
    return finishBrokerAuthentication(context,federatedUser,clientSession,providerId);
  }
}
