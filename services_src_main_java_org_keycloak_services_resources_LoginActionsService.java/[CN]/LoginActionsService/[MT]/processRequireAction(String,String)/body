{
  event.event(EventType.CUSTOM_REQUIRED_ACTION);
  event.detail(Details.CUSTOM_REQUIRED_ACTION,action);
  Checks checks=new Checks();
  if (!checks.verifyCode(code,ClientSessionModel.Action.REQUIRED_ACTIONS.name())) {
    return checks.response;
  }
  final ClientSessionCode clientCode=checks.clientCode;
  final ClientSessionModel clientSession=clientCode.getClientSession();
  if (clientSession.getUserSession() == null) {
    logger.error("user session was null");
    event.error(Errors.USER_SESSION_NOT_FOUND);
    throw new WebApplicationException(ErrorPage.error(session,Messages.SESSION_NOT_ACTIVE));
  }
  if (action == null && clientSession.getUserSession() != null) {
    initEvent(clientSession);
    event.event(EventType.LOGIN);
    return AuthenticationManager.nextActionAfterAuthentication(session,clientSession.getUserSession(),clientSession,clientConnection,request,uriInfo,event);
  }
  if (!action.equals(clientSession.getNote(AuthenticationManager.CURRENT_REQUIRED_ACTION))) {
    logger.error("required action doesn't match current required action");
    event.error(Errors.INVALID_CODE);
    throw new WebApplicationException(ErrorPage.error(session,Messages.INVALID_CODE));
  }
  RequiredActionFactory factory=(RequiredActionFactory)session.getKeycloakSessionFactory().getProviderFactory(RequiredActionProvider.class,action);
  if (factory == null) {
    logger.error("required action provider was null");
    event.error(Errors.INVALID_CODE);
    throw new WebApplicationException(ErrorPage.error(session,Messages.INVALID_CODE));
  }
  RequiredActionProvider provider=factory.create(session);
  initEvent(clientSession);
  event.event(EventType.CUSTOM_REQUIRED_ACTION);
  RequiredActionContextResult context=new RequiredActionContextResult(clientSession.getUserSession(),clientSession,realm,event,session,request,clientSession.getUserSession().getUser(),factory){
    @Override public void ignore(){
      throw new RuntimeException("Cannot call ignore within processAction()");
    }
  }
;
  provider.processAction(context);
  if (context.getStatus() == RequiredActionContext.Status.SUCCESS) {
    event.success();
    clientSession.removeRequiredAction(factory.getId());
    clientSession.getUserSession().getUser().removeRequiredAction(factory.getId());
    URI redirect=LoginActionsService.loginActionsBaseUrl(uriInfo).path(LoginActionsService.REQUIRED_ACTION).queryParam(OAuth2Constants.CODE,code).build(realm.getName());
    return Response.status(302).location(redirect).build();
  }
  if (context.getStatus() == RequiredActionContext.Status.CHALLENGE) {
    return context.getChallenge();
  }
  if (context.getStatus() == RequiredActionContext.Status.FAILURE) {
    LoginProtocol protocol=context.getSession().getProvider(LoginProtocol.class,context.getClientSession().getAuthMethod());
    protocol.setRealm(context.getRealm()).setHttpHeaders(context.getHttpRequest().getHttpHeaders()).setUriInfo(context.getUriInfo());
    event.detail(Details.CUSTOM_REQUIRED_ACTION,action).error(Errors.REJECTED_BY_USER);
    return protocol.sendError(context.getClientSession(),Error.CONSENT_DENIED);
  }
  throw new RuntimeException("Unreachable");
}
