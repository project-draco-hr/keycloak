{
  Map<String,String[]> queryParams=getQueryParams();
  RequestDetails requestData=getRequestDetails(queryParams);
  SocialProvider provider=getProvider(requestData.getProviderId());
  String realmId=requestData.getClientAttribute("realmId");
  RealmManager realmManager=new RealmManager(session);
  RealmModel realm=realmManager.getRealm(realmId);
  OAuthFlows oauth=Flows.oauth(realm,request,uriInfo,authManager,tokenManager);
  if (!realm.isEnabled()) {
    return oauth.forwardToSecurityFailure("Realm not enabled.");
  }
  String clientId=requestData.getClientAttributes().get("clientId");
  UserModel client=realm.getUser(clientId);
  if (client == null) {
    return oauth.forwardToSecurityFailure("Unknown login requester.");
  }
  if (!client.isEnabled()) {
    return oauth.forwardToSecurityFailure("Login requester not enabled.");
  }
  String key=realm.getSocialConfig().get(requestData.getProviderId() + ".key");
  String secret=realm.getSocialConfig().get(requestData.getProviderId() + ".secret");
  String callbackUri=Urls.socialCallback(uriInfo.getBaseUri()).toString();
  SocialProviderConfig config=new SocialProviderConfig(key,secret,callbackUri);
  AuthCallback callback=new AuthCallback(requestData.getSocialAttributes(),queryParams);
  SocialUser socialUser=null;
  try {
    socialUser=provider.processCallback(config,callback);
  }
 catch (  SocialProviderException e) {
    logger.warn("Failed to process social callback",e);
    return oauth.forwardToSecurityFailure("Failed to process social callback");
  }
  SocialLinkModel socialLink=new SocialLinkModel(provider.getId(),socialUser.getUsername());
  UserModel user=realm.getUserBySocialLink(socialLink);
  if (user == null) {
    if (!realm.isRegistrationAllowed()) {
      return oauth.forwardToSecurityFailure("Registration not allowed");
    }
    if (realm.isAutomaticRegistrationAfterSocialLogin()) {
      if (realm.getUser(socialUser.getUsername()) != null) {
        throw new IllegalStateException("Username " + socialUser.getUsername() + " already registered in the realm. TODO: bind accounts...");
      }
 else {
        user=realm.addUser(socialUser.getUsername());
        user.setFirstName(socialUser.getFirstName());
        user.setLastName(socialUser.getLastName());
        user.setEmail(socialUser.getEmail());
      }
      realm.addSocialLink(user,socialLink);
      for (      RoleModel role : realm.getDefaultRoles()) {
        realm.grantRole(user,role);
      }
    }
 else {
      MultivaluedMap<String,String> formData=fillRegistrationFormWithSocialData(socialUser);
      RequestDetailsBuilder reqDetailsBuilder=RequestDetailsBuilder.createFromRequestDetails(requestData);
      reqDetailsBuilder.putSocialAttribute(SocialConstants.ATTR_SOCIAL_LINK,socialLink);
      String requestId=UUID.randomUUID().toString();
      socialRequestManager.addRequest(requestId,reqDetailsBuilder.build());
      boolean secureOnly=!realm.isSslNotRequired();
      String cookiePath=Urls.socialBase(uriInfo.getBaseUri()).build().getPath();
      logger.info("creating cookie for social registration - name: " + SocialConstants.SOCIAL_REGISTRATION_COOKIE + " path: "+ cookiePath);
      NewCookie newCookie=new NewCookie(SocialConstants.SOCIAL_REGISTRATION_COOKIE,requestId,cookiePath,null,"Added social cookie",NewCookie.DEFAULT_MAX_AGE,secureOnly);
      response.addNewCookie(newCookie);
      return Flows.forms(realm,request,uriInfo).setFormData(formData).setSocialRegistration(true).forwardToRegistration();
    }
  }
  if (!user.isEnabled()) {
    return oauth.forwardToSecurityFailure("Your account is not enabled.");
  }
  String scope=requestData.getClientAttributes().get("scope");
  String state=requestData.getClientAttributes().get("state");
  String redirectUri=requestData.getClientAttributes().get("redirectUri");
  return oauth.processAccessCode(scope,state,redirectUri,client,user);
}
