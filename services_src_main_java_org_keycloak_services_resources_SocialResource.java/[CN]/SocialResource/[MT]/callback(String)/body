{
  State initialRequest;
  try {
    initialRequest=new JWSInput(encodedState).readJsonContent(State.class);
  }
 catch (  Throwable t) {
    logger.warn("Invalid social callback",t);
    return Flows.forms(session,null,null,uriInfo).setError("Unexpected callback").createErrorPage();
  }
  SocialProvider provider=SocialLoader.load(initialRequest.getProvider());
  String realmName=initialRequest.getRealm();
  String authMethod="social@" + provider.getId();
  RealmManager realmManager=new RealmManager(session);
  RealmModel realm=realmManager.getRealmByName(realmName);
  Audit audit=new AuditManager(realm,session,clientConnection).createAudit().event(EventType.LOGIN).detail(Details.RESPONSE_TYPE,initialRequest.get(OAuth2Constants.RESPONSE_TYPE)).detail(Details.AUTH_METHOD,authMethod);
  AuthenticationManager authManager=new AuthenticationManager();
  OAuthFlows oauth=Flows.oauth(session,realm,request,uriInfo,clientConnection,authManager,tokenManager);
  if (!realm.isEnabled()) {
    audit.error(Errors.REALM_DISABLED);
    return oauth.forwardToSecurityFailure("Realm not enabled.");
  }
  String clientId=initialRequest.get(OAuth2Constants.CLIENT_ID);
  String redirectUri=initialRequest.get(OAuth2Constants.REDIRECT_URI);
  String scope=initialRequest.get(OAuth2Constants.SCOPE);
  String state=initialRequest.get(OAuth2Constants.STATE);
  String responseType=initialRequest.get(OAuth2Constants.RESPONSE_TYPE);
  audit.client(clientId).detail(Details.REDIRECT_URI,redirectUri);
  ClientModel client=realm.findClient(clientId);
  if (client == null) {
    audit.error(Errors.CLIENT_NOT_FOUND);
    return oauth.forwardToSecurityFailure("Unknown login requester.");
  }
  if (!client.isEnabled()) {
    audit.error(Errors.CLIENT_DISABLED);
    return oauth.forwardToSecurityFailure("Login requester not enabled.");
  }
  String key=realm.getSocialConfig().get(provider.getId() + ".key");
  String secret=realm.getSocialConfig().get(provider.getId() + ".secret");
  String callbackUri=Urls.socialCallback(uriInfo.getBaseUri()).toString();
  SocialProviderConfig config=new SocialProviderConfig(key,secret,callbackUri);
  Map<String,String[]> queryParams=getQueryParams();
  Map<String,String> attributes=getAttributes();
  AuthCallback callback=new AuthCallback(queryParams,attributes);
  SocialUser socialUser;
  try {
    socialUser=provider.processCallback(config,callback);
  }
 catch (  SocialAccessDeniedException e) {
    MultivaluedMap<String,String> queryParms=new MultivaluedMapImpl<String,String>();
    queryParms.putSingle(OAuth2Constants.CLIENT_ID,clientId);
    queryParms.putSingle(OAuth2Constants.STATE,state);
    queryParms.putSingle(OAuth2Constants.SCOPE,scope);
    queryParms.putSingle(OAuth2Constants.REDIRECT_URI,redirectUri);
    queryParms.putSingle(OAuth2Constants.RESPONSE_TYPE,responseType);
    audit.error(Errors.REJECTED_BY_USER);
    return Flows.forms(session,realm,client,uriInfo).setQueryParams(queryParms).setWarning("Access denied").createLogin();
  }
catch (  SocialProviderException e) {
    logger.error("Failed to process social callback",e);
    return oauth.forwardToSecurityFailure("Failed to process social callback");
  }
  audit.detail(Details.USERNAME,socialUser.getId() + "@" + provider.getId());
  SocialLinkModel socialLink=new SocialLinkModel(provider.getId(),socialUser.getId(),socialUser.getUsername());
  UserModel user=session.users().getUserBySocialLink(socialLink,realm);
  String userId=initialRequest.getUser();
  if (userId != null) {
    UserModel authenticatedUser=session.users().getUserById(userId,realm);
    audit.event(EventType.SOCIAL_LINK).user(userId);
    if (user != null) {
      audit.error(Errors.SOCIAL_ID_IN_USE);
      return oauth.forwardToSecurityFailure("This social account is already linked to other user");
    }
    if (!authenticatedUser.isEnabled()) {
      audit.error(Errors.USER_DISABLED);
      return oauth.forwardToSecurityFailure("User is disabled");
    }
    if (!authenticatedUser.hasRole(realm.getApplicationByName(Constants.ACCOUNT_MANAGEMENT_APP).getRole(AccountRoles.MANAGE_ACCOUNT))) {
      audit.error(Errors.NOT_ALLOWED);
      return oauth.forwardToSecurityFailure("Insufficient permissions to link social account");
    }
    if (redirectUri == null) {
      audit.error(Errors.INVALID_REDIRECT_URI);
      return oauth.forwardToSecurityFailure("Unknown redirectUri");
    }
    session.users().addSocialLink(realm,authenticatedUser,socialLink);
    logger.debug("Social provider " + provider.getId() + " linked with user "+ authenticatedUser.getUsername());
    audit.success();
    return Response.status(302).location(UriBuilder.fromUri(redirectUri).build()).build();
  }
  if (user == null) {
    user=session.users().addUser(realm,KeycloakModelUtils.generateId());
    user.setEnabled(true);
    user.setFirstName(socialUser.getFirstName());
    user.setLastName(socialUser.getLastName());
    user.setEmail(socialUser.getEmail());
    if (realm.isUpdateProfileOnInitialSocialLogin()) {
      user.addRequiredAction(UserModel.RequiredAction.UPDATE_PROFILE);
    }
    session.users().addSocialLink(realm,user,socialLink);
    audit.clone().user(user).event(EventType.REGISTER).detail(Details.REGISTER_METHOD,"social@" + provider.getId()).detail(Details.EMAIL,socialUser.getEmail()).removeDetail("auth_method").success();
  }
  audit.user(user);
  if (!user.isEnabled()) {
    audit.error(Errors.USER_DISABLED);
    return oauth.forwardToSecurityFailure("Your account is not enabled.");
  }
  String username=socialLink.getSocialUserId() + "@" + socialLink.getSocialProvider();
  UserSessionModel userSession=session.sessions().createUserSession(realm,user,username,clientConnection.getRemoteAddr(),authMethod,false);
  audit.session(userSession);
  return oauth.processAccessCode(scope,state,redirectUri,client,user,userSession,audit);
}
