{
  auth.requireManage();
  logger.debug("updating realm: " + realm.getName());
  try {
    RepresentationToModel.updateRealm(rep,realm);
    if (rep.isRealmCacheEnabled() != null && session.realms() instanceof CacheRealmProvider) {
      CacheRealmProvider cacheRealmProvider=(CacheRealmProvider)session.realms();
      cacheRealmProvider.setEnabled(rep.isRealmCacheEnabled());
    }
    if (rep.isUserCacheEnabled() != null && session.userStorage() instanceof CacheUserProvider) {
      CacheUserProvider cache=(CacheUserProvider)session.userStorage();
      cache.setEnabled(rep.isUserCacheEnabled());
    }
    List<UserFederationProviderModel> federationProviders=realm.getUserFederationProviders();
    UsersSyncManager usersSyncManager=new UsersSyncManager();
    for (    final UserFederationProviderModel fedProvider : federationProviders) {
      usersSyncManager.refreshPeriodicSyncForProvider(session.getKeycloakSessionFactory(),session.getProvider(TimerProvider.class),fedProvider,realm.getId());
    }
    adminEvent.operation(OperationType.UPDATE).resourcePath(uriInfo.getPath()).representation(rep).success();
    return Response.noContent().build();
  }
 catch (  PatternSyntaxException e) {
    return ErrorResponse.exists("Specified regex pattern(s) is invalid.");
  }
catch (  ModelDuplicateException e) {
    return ErrorResponse.exists("Realm " + rep.getRealm() + " already exists.");
  }
catch (  Exception e) {
    return ErrorResponse.exists("Failed to update " + rep.getRealm() + " Realm.");
  }
}
