{
  auth.requireManage();
  logger.debug("updating realm: " + realm.getName());
  try {
    RepresentationToModel.updateRealm(rep,realm);
    if (rep.isRealmCacheEnabled() != null && session.realms() instanceof CacheRealmProvider) {
      CacheRealmProvider cacheRealmProvider=(CacheRealmProvider)session.realms();
      cacheRealmProvider.setEnabled(rep.isRealmCacheEnabled());
    }
    if (rep.isUserCacheEnabled() != null && session.userStorage() instanceof CacheUserProvider) {
      CacheUserProvider cache=(CacheUserProvider)session.userStorage();
      cache.setEnabled(rep.isUserCacheEnabled());
    }
    List<UserFederationProviderModel> federationProviders=realm.getUserFederationProviders();
    UsersSyncManager usersSyncManager=new UsersSyncManager();
    for (    final UserFederationProviderModel fedProvider : federationProviders) {
      usersSyncManager.refreshPeriodicSyncForProvider(session.getKeycloakSessionFactory(),session.getProvider(TimerProvider.class),fedProvider,realm.getId());
    }
    event.event(EventType.UPDATE_REALM).success();
    return Response.noContent().build();
  }
 catch (  ModelDuplicateException e) {
    return Flows.errors().exists("Realm " + rep.getRealm() + " already exists");
  }
}
