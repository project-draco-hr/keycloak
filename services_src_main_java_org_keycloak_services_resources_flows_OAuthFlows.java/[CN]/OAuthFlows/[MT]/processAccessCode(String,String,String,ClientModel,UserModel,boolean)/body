{
  isTotpConfigurationRequired(user);
  isEmailVerificationRequired(user);
  RoleModel resourceRole=realm.getRole(Constants.APPLICATION_ROLE);
  RoleModel identityRequestRole=realm.getRole(Constants.IDENTITY_REQUESTER_ROLE);
  boolean isResource=realm.hasRole(client.getAgent(),resourceRole);
  if (!isResource && !realm.hasRole(client.getAgent(),identityRequestRole)) {
    return forwardToSecurityFailure("Login requester not allowed to request login.");
  }
  AccessCodeEntry accessCode=tokenManager.createAccessCode(scopeParam,state,redirect,realm,client,user);
  log.debug("processAccessCode: isResource: {0}",isResource);
  log.debug("processAccessCode: go to oauth page?: {0}",(!isResource && (accessCode.getRealmRolesRequested().size() > 0 || accessCode.getResourceRolesRequested().size() > 0)));
  Set<RequiredAction> requiredActions=user.getRequiredActions();
  if (!requiredActions.isEmpty()) {
    accessCode.setRequiredActions(new HashSet<UserModel.RequiredAction>(requiredActions));
    accessCode.setExpiration(System.currentTimeMillis() / 1000 + realm.getAccessCodeLifespanUserAction());
    return Flows.forms(realm,request,uriInfo).setAccessCode(accessCode.getId(),accessCode.getCode()).setUser(user).createResponse(user.getRequiredActions().iterator().next());
  }
  if (!isResource && (accessCode.getRealmRolesRequested().size() > 0 || accessCode.getResourceRolesRequested().size() > 0)) {
    OAuthClientModel oauthClient=realm.getOAuthClient(client.getAgent().getLoginName());
    accessCode.setExpiration(System.currentTimeMillis() / 1000 + realm.getAccessCodeLifespanUserAction());
    return Flows.forms(realm,request,uriInfo).setAccessCode(accessCode.getId(),accessCode.getCode()).setAccessRequest(accessCode.getRealmRolesRequested(),accessCode.getResourceRolesRequested()).setClient(client).createOAuthGrant();
  }
  if (redirect != null) {
    return redirectAccessCode(accessCode,state,redirect,rememberMe);
  }
 else {
    return null;
  }
}
