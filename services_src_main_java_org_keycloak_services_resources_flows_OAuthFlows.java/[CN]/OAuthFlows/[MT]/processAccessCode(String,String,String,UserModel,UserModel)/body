{
  RoleModel resourceRole=realm.getRole(Constants.APPLICATION_ROLE);
  RoleModel identityRequestRole=realm.getRole(Constants.IDENTITY_REQUESTER_ROLE);
  boolean isResource=realm.hasRole(client,resourceRole);
  if (!isResource && !realm.hasRole(client,identityRequestRole)) {
    return forwardToSecurityFailure("Login requester not allowed to request login.");
  }
  AccessCodeEntry accessCode=tokenManager.createAccessCode(scopeParam,state,redirect,realm,client,user);
  log.debug("processAccessCode: isResource: {0}",isResource);
  log.debug("processAccessCode: go to oauth page?: {0}",(!isResource && (accessCode.getRealmRolesRequested().size() > 0 || accessCode.getResourceRolesRequested().size() > 0)));
  Set<RequiredAction> requiredActions=user.getRequiredActions();
  if (!requiredActions.isEmpty()) {
    accessCode.setRequiredActions(new HashSet<UserModel.RequiredAction>(requiredActions));
    accessCode.setExpiration(System.currentTimeMillis() / 1000 + realm.getAccessCodeLifespanUserAction());
    return Flows.forms(realm,request,uriInfo).setAccessCode(accessCode).setUser(user).forwardToAction(user.getRequiredActions().iterator().next());
  }
  if (!isResource && (accessCode.getRealmRolesRequested().size() > 0 || accessCode.getResourceRolesRequested().size() > 0)) {
    accessCode.setExpiration(System.currentTimeMillis() / 1000 + realm.getAccessCodeLifespanUserAction());
    return oauthGrantPage(accessCode,client);
  }
  if (redirect != null) {
    return redirectAccessCode(accessCode,state,redirect);
  }
 else {
    return null;
  }
}
